# Source Generator ガイド

Crisp の Source Generator は、`[BehaviorTree]` 属性が付けられたメソッドに対して、DSL からコンパイル時に C# コードを自動生成します。

## 目次

- [概要](#概要)
- [セットアップ](#セットアップ)
- [インライン S 式](#インライン-s-式)
- [外部ファイル](#外部ファイル)
- [生成されるコード](#生成されるコード)
- [AOT アクセサの生成](#aot-アクセサの生成)
- [IR 最適化](#ir-最適化)
- [ビルド診断](#ビルド診断)
- [トラブルシューティング](#トラブルシューティング)

## 概要

```
  [BehaviorTree("(tree T ...)")]
        │
        ▼
  ┌──────────┐     ┌──────────┐     ┌──────────┐
  │  Lexer   │ ──▶ │  Parser  │ ──▶ │ Lowering │
  │(トークン化)│     │(構文解析) │     │(CST→AST) │
  └──────────┘     └──────────┘     └────┬─────┘
                                         │
                      ┌──────────────────┘
                      ▼
             ┌──────────────────┐
             │  SemanticAnalyzer │
             │  ┌─────────────┐ │
             │  │NameResolver │ │  ← Roslyn の型情報を使用
             │  │TypeInferer  │ │
             │  │TypeChecker  │ │
             │  └─────────────┘ │
             └────────┬─────────┘
                      │
             ┌────────┴────────┐
             ▼                 ▼
    ┌──────────────┐  ┌──────────────┐
    │ IR Optimizer │  │ AOT Accessor │
    │  (最適化)     │  │  Generator   │
    └──────┬───────┘  └──────────────┘
           ▼
    ┌──────────────┐
    │ CSharpEmitter │
    │  (C# 出力)    │
    └──────────────┘
```

Source Generator は以下の処理をビルド時に実行します:

1. `[BehaviorTree]` 属性のついたメソッドを検出
2. DSL ソースを読み込む（インライン文字列または外部ファイル）
3. Lexer → Parser → AST → セマンティック解析 → IR → 最適化 → C# コード生成
4. 生成したコードを `partial` メソッドの実装として出力
5. コンテキスト型に対する AOT アクセサテーブルを生成
6. エラーがあればビルド診断として報告

Source Generator と LSP サーバーは同じ `QueryDatabase`（増分計算エンジン）を共有しているため、エディタ上の診断とビルド時の診断は一致します。

## セットアップ

### .csproj の設定

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <!-- ランタイムライブラリ -->
    <PackageReference Include="Crisp.Runtime" Version="*" />

    <!-- Source Generator（アナライザーとして参照） -->
    <PackageReference Include="Crisp.SourceGenerator" Version="*"
                      OutputItemType="Analyzer"
                      ReferenceOutputAssembly="false" />
  </ItemGroup>
</Project>
```

`OutputItemType="Analyzer"` と `ReferenceOutputAssembly="false"` の両方が必要です。

### コンテキストクラスの要件

```csharp
// 1. partial キーワードが必須
public partial class MyAI
{
    // 2. DSL から参照するプロパティ・メソッドを定義
    public int Health { get; set; }
    public BtStatus Patrol() => BtStatus.Success;

    // 3. partial メソッドに [BehaviorTree] を付与
    //    戻り値は BtNode、引数なし
    [BehaviorTree("(tree T (.Patrol))")]
    public partial BtNode BuildTree();
}
```

## インライン S 式

DSL コードを属性引数に直接記述する方法です。短いツリーに適しています。

```csharp
[BehaviorTree("(tree Combat (select (seq (check (< .Health 30)) (.Flee)) (.Patrol)))")]
public partial BtNode BuildTree();
```

C# の raw string literal を使うと、複数行の DSL をきれいに記述できます:

```csharp
[BehaviorTree("""
    (tree Combat
      (select
        (seq
          (check (< .Health 30))
          (.Flee))
        (.Patrol)))
    """)]
public partial BtNode BuildTree();
```

## 外部ファイル

DSL コードを `.crisp` ファイルに分離する方法です。長いツリーや複数のクラスで共有する場合に適しています。

### 1. `.crisp` ファイルを作成

```lisp
;; Combat.crisp
(tree Combat
  (select
    (seq
      (check (< .Health 30))
      (.Flee))
    (.Patrol)))
```

### 2. `.csproj` に AdditionalFiles として登録

```xml
<ItemGroup>
  <AdditionalFiles Include="Combat.crisp" />
</ItemGroup>
```

ワイルドカードも使用できます:

```xml
<ItemGroup>
  <AdditionalFiles Include="**/*.crisp" />
</ItemGroup>
```

### 3. 属性でファイル名を指定

```csharp
[BehaviorTree("Combat.crisp")]
public partial BtNode BuildTree();
```

ファイル名の照合はファイル名部分のみで行われ、大文字小文字は区別しません。

## 生成されるコード

Source Generator は `{クラス名}.{メソッド名}.g.cs` というファイルを生成します。

### 入力例

```csharp
namespace Game.AI;

public partial class EnemyAI
{
    public int Health { get; set; }
    public BtStatus Flee() => BtStatus.Success;
    public BtStatus Patrol() => BtStatus.Success;

    [BehaviorTree("""
        (tree Combat
          (select
            (seq (check (< .Health 30)) (.Flee))
            (.Patrol)))
        """)]
    public partial BtNode BuildTree();
}
```

### 出力例

```csharp
// <auto-generated by Crisp Source Generator/>
#nullable enable

using Crisp.Runtime.Nodes;

namespace Game.AI;

partial class EnemyAI
{
    public partial Crisp.Runtime.BtNode BuildTree()
    {
        return new Crisp.Runtime.Nodes.SelectorNode(
            new Crisp.Runtime.Nodes.SequenceNode(
                new Crisp.Runtime.Nodes.ConditionNode(() => (this.Health < 30), ".Health < 30"),
                new Crisp.Runtime.Nodes.ActionNode(() => this.Flee(), "Flee()")),
            new Crisp.Runtime.Nodes.ActionNode(() => this.Patrol(), "Patrol()"));
    }
}
```

### BtNode を返すメソッド（サブツリー埋め込み）

`BtNode` を返すメソッドをアクション位置で呼び出すと、`ActionNode` でラップされずに直接呼び出しとしてコード生成されます。

```csharp
// 入力
public partial class EnemyAI
{
    public BtNode BuildCombat() => new SequenceNode(
        new ConditionNode(() => this.IsEnemyVisible),
        new ActionNode(() => this.Attack()));

    public BtStatus Patrol() => BtStatus.Success;

    [BehaviorTree("(tree Main (select (.BuildCombat) (.Patrol)))")]
    public partial BtNode BuildTree();
}
```

```csharp
// 生成コード
public partial Crisp.Runtime.BtNode BuildTree()
{
    return new Crisp.Runtime.Nodes.SelectorNode(
        this.BuildCombat(),                                                // BtNode → 直接呼び出し
        new Crisp.Runtime.Nodes.ActionNode(() => this.Patrol(), "Patrol()")); // BtStatus → ActionNode ラップ
}
```

### 生成コードの特徴

- `this.` を通じてコンテキストクラスのメンバーを直接参照
- ラムダ式でプロパティアクセスやメソッド呼び出しをラップ
- `BtStatus` を返すメソッドは `ActionNode(() => ..., "ラベル")` でラップ
- `BtNode` を返すメソッドは `this.Method()` として直接呼び出し（サブツリー埋め込み）
- 完全修飾名を使用（名前衝突を防止）
- マルチツリーの `ref` は別メソッド呼び出しとして展開
- リアクティブノードは `ReactiveNode` / `ReactiveSelectorNode` に変換
- 非同期アクションは `AsyncActionNode` に変換
- デバッグラベルの自動生成（下記参照）

### デバッグラベル生成

Source Generator は `ConditionNode`・`ActionNode`・`AsyncActionNode` の生成時に、DSL の式をテキスト表現に変換した文字列を `debugLabel` 引数として付与します。このラベルは `BtDebugger` のスナップショットや `BtDebugFormatter` の出力に使用されます。

| ノード型 | DSL | 生成されるラベル |
|---|---|---|
| ConditionNode | `(check (< .Health 30))` | `".Health < 30"` |
| ConditionNode | `(check .IsEnemyVisible)` | `".IsEnemyVisible"` |
| ConditionNode | `(check (and .A .B))` | `".A and .B"` |
| ActionNode | `(.Patrol)` | `"Patrol()"` |
| ActionNode | `(.Attack .Target)` | `"Attack(.Target)"` |
| AsyncActionNode | `(.NavigateTo)` | `"NavigateTo()"` |

`BtNode` を返すサブツリーメソッドの場合は `ActionNode` でラップされないため、デバッグラベルは付与されません。サブツリー内のノードは、そのサブツリーを構築する C# コード側で個別にラベルを設定できます。

ラベルの生成には `TreeLayoutBuilder.FormatExpr()` / `FormatAction()` が使用され、ビジュアルエディタのノードラベルと同じ文字列が生成されます。

## AOT アクセサの生成

Source Generator は、NativeAOT / IL2CPP 環境でリフレクション不要のメンバーアクセスを可能にするアクセサテーブルを自動生成します。

### 生成ファイル

`{クラス名}.Accessors.g.cs` として生成されます。同一クラス内に複数の `[BehaviorTree]` メソッドがある場合でも、アクセサテーブルは 1 回のみ生成されます（重複排除）。

### 生成内容

```csharp
partial class EnemyAI
{
    private static readonly Dictionary<string, Func<EnemyAI, object?>> _crispMemberAccessors = new()
    {
        ["Health"] = ctx => ctx.Health,
        ["IsEnemyVisible"] = ctx => ctx.IsEnemyVisible,
    };

    private static readonly Dictionary<string, Func<EnemyAI, object?[], object?>> _crispMethodInvokers = new()
    {
        ["Patrol"] = (ctx, args) => ctx.Patrol(),
        ["Flee"] = (ctx, args) => ctx.Flee(),
        ["Attack"] = (ctx, args) => ctx.Attack((string)args[0]),
    };

    public static IAccessorTable<EnemyAI> GetAccessorTable()
        => new AccessorTable<EnemyAI>(_crispMemberAccessors, _crispMethodInvokers);
}
```

### 対象メンバー

- **プロパティ:** `public`, `internal`, `protected` のインスタンスプロパティ（`static`, `indexer` を除く）
- **フィールド:** `public`, `internal`, `protected` のインスタンスフィールド（`static` を除く）
- **メソッド:** `public`, `internal`, `protected` の通常メソッド（`static` を除く）

### チェーンアクセスの型

`.Target.Position.x` のようなチェーンアクセスで、中間の型（`Position`）にもアクセサが必要な場合、対象型に `[CrispAccessible]` 属性を付与してください:

```csharp
[CrispAccessible]
public class Position
{
    public float X { get; set; }
    public float Y { get; set; }
}
```

## IR 最適化

Source Generator はコード生成前に IR レベルの最適化パスを適用します。全てのパスは正当性を保ったまま実行時のオーバーヘッドを削減します。

### Pass 1: 定数畳み込み (Constant Folding)

リテラル同士の演算をコンパイル時に計算します。

```
最適化前: (+ 10 20) → 最適化後: 30
```

### Pass 2: 到達不能ノード除去 (Dead Node Elimination)

常に Success/Failure を返すノードの後の到達不能ノードを除去します。

```
最適化前: (seq (check false) (.Attack)) → 最適化後: (check false)
```

### Pass 3: 単一子ノードの畳み込み (Single-Child Collapse)

子が 1 つだけのコンポジットノードや二重反転を簡約します。

```
最適化前: (select (.Patrol))     → 最適化後: (.Patrol)
最適化前: (invert (invert child)) → 最適化後: child
```

### Pass 5: 型変換の統合 (Convert Fusion)

冗長な型変換を統合し、リテラルの型変換をインライン化します。

```
最適化前: (convert (convert x float) float) → 最適化後: (convert x float)
最適化前: (convert 42 float)                → 最適化後: 42.0
```

## ビルド診断

Source Generator はコンパイルエラーをビルド診断として報告します。

### CRISP0001: コンパイルエラー

DSL の構文エラーまたはセマンティックエラーが検出された場合に報告されます。メッセージには Crisp の内部診断コード（`BS0001` 等）が含まれます。

```
error CRISP0001: BS0001: Member 'Unknown' not found on type 'Game.AI.EnemyAI'
```

### CRISP0011: 外部ファイル未検出

指定されたファイルが `AdditionalFiles` に含まれていない場合に報告されます。

```
error CRISP0011: External .crisp file 'Combat.crisp' not found in AdditionalFiles
```

### CRISP0900: 内部エラー

Source Generator 内部で予期しないエラーが発生した場合に報告されます。

## トラブルシューティング

### 生成されたコードが見えない

**対処法:**
1. ソリューションをクリーンビルドする: `dotnet clean && dotnet build`
2. IDE を再起動する
3. `obj/` フォルダを削除して再ビルドする

### "partial method must have an implementation" エラー

**対処法:**
1. ビルドログで `CRISP0001` や `CRISP0011` エラーを確認する
2. `[BehaviorTree]` 属性のソース文字列が正しいか確認する
3. メソッドが `partial` で戻り値が `BtNode` であることを確認する

### 外部ファイルが認識されない

**対処法:**
1. `.csproj` に `<AdditionalFiles Include="filename.crisp" />` が含まれていることを確認する
2. ファイル名のスペルが正しいことを確認する（大文字小文字は区別しません）

### 型エラーが報告される

**対処法:**
1. エラーメッセージの `BS0xxx` コードを[診断メッセージ一覧](diagnostics.md)で確認する
2. コンテキストクラスのプロパティ名・メソッド名のスペルを確認する
3. アクションメソッドが `BtStatus` または `BtNode` を返しているか確認する
4. `check` 式が `bool` を返しているか確認する

### 警告が出るがビルドは成功する

Warning / Info レベルの診断はコード生成を妨げません。詳細は[診断メッセージ一覧](diagnostics.md)を参照してください。
