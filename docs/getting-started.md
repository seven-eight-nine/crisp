# はじめに

このガイドでは、Crisp を使って最初のビヘイビアツリーを作成するまでの手順を説明します。基本的なツリーから始めて、段階的により高度な機能を紹介します。

## 目次

- [前提条件](#前提条件)
- [インストール](#インストール)
- [チュートリアル 1: 最初のビヘイビアツリー](#チュートリアル-1-最初のビヘイビアツリー)
- [チュートリアル 2: サブツリーの再利用](#チュートリアル-2-サブツリーの再利用)
- [チュートリアル 3: 条件分岐とデコレータ](#チュートリアル-3-条件分岐とデコレータ)
- [チュートリアル 4: リアクティブノード](#チュートリアル-4-リアクティブノード)
- [チュートリアル 5: ブラックボード](#チュートリアル-5-ブラックボード)
- [チュートリアル 6: defdec でカスタムノードを定義する](#チュートリアル-6-defdec-でカスタムノードを定義する)
- [チュートリアル 7: 非同期アクション](#チュートリアル-7-非同期アクション)
- [チュートリアル 8: デバッガ](#チュートリアル-8-デバッガ)
- [外部ファイルの使い方](#外部ファイルの使い方)
- [マルチツリー](#マルチツリー)
- [ホットリロード](#ホットリロード)
- [次のステップ](#次のステップ)

## 前提条件

- [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) 以降

## インストール

### NuGet パッケージとして追加

プロジェクトの `.csproj` ファイルに以下の参照を追加します。

```xml
<ItemGroup>
  <PackageReference Include="Crisp.Runtime" Version="*" />
  <PackageReference Include="Crisp.SourceGenerator" Version="*"
                    OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
</ItemGroup>
```

`Crisp.Runtime` はビヘイビアツリーの実行に必要なランタイムライブラリです。`Crisp.SourceGenerator` はビルド時に DSL から C# コードを生成する Source Generator で、`OutputItemType="Analyzer"` と `ReferenceOutputAssembly="false"` の指定が必須です。

### ソースから参照する場合

リポジトリをクローンし、プロジェクト参照として追加することもできます。

```xml
<ItemGroup>
  <ProjectReference Include="../crisp/src/Crisp.Runtime/Crisp.Runtime.csproj" />
  <ProjectReference Include="../crisp/src/Crisp.SourceGenerator/Crisp.SourceGenerator.csproj"
                    OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
</ItemGroup>
```

## チュートリアル 1: 最初のビヘイビアツリー

敵 AI の簡単な戦闘ロジックを Crisp で実装します。

### ステップ 1: コンテキストクラスを作成する

ビヘイビアツリーは「コンテキストクラス」のメンバー（プロパティ・メソッド）を参照します。まず、AI の状態とアクションを定義します。

```csharp
using Crisp.Runtime;

public partial class EnemyAI
{
    // === プロパティ: ツリーから参照される状態 ===
    public int Health { get; set; } = 100;
    public bool IsEnemyVisible { get; set; }

    // === メソッド: ツリーから呼び出されるアクション ===
    // アクションメソッドは BtStatus を返す必要がある
    public BtStatus Patrol()
    {
        Console.WriteLine("パトロール中...");
        return BtStatus.Success;
    }

    public BtStatus Flee()
    {
        Console.WriteLine("逃走中...");
        return BtStatus.Success;
    }

    public BtStatus Attack()
    {
        Console.WriteLine("攻撃!");
        return BtStatus.Success;
    }
}
```

重要なポイント:
- クラスに `partial` キーワードが必要です（Source Generator がコードを追加するため）
- アクションメソッドは `BtStatus` または `BtNode` を返す必要があります
  - `BtStatus` を返す → 毎 tick 実行されるアクション
  - `BtNode` を返す → ビルド時に 1 回呼ばれ、サブツリーとして埋め込み
- プロパティは任意の型を使用できます（`int`, `float`, `bool`, `string` 等）

### ステップ 2: ビヘイビアツリーを定義する

コンテキストクラスに `[BehaviorTree]` 属性を付けた `partial` メソッドを追加します。

```csharp
public partial class EnemyAI
{
    // ...（上記のプロパティ・メソッド）

    [BehaviorTree("""
        (tree EnemyCombat
          (select
            ;; 体力が少ない場合は逃げる
            (seq
              (check (< .Health 30))
              (.Flee))
            ;; 敵が見えたら攻撃
            (seq
              (check .IsEnemyVisible)
              (.Attack))
            ;; デフォルト: パトロール
            (.Patrol)))
        """)]
    public partial BtNode BuildTree();
}
```

DSL の基本構文:
- `(tree 名前 ...)` — ツリーを定義する
- `(select ...)` — 子ノードを順に評価し、最初に成功したものを採用（セレクター）
- `(seq ...)` — 子ノードを順に評価し、全て成功する必要がある（シーケンス）
- `(check 式)` — 式を評価し、`true` なら Success、`false` なら Failure
- `.Health` — コンテキストクラスのプロパティを参照
- `(.Flee)` — コンテキストクラスのメソッドを呼び出す
- `(< .Health 30)` — 比較式（前置記法）
- `;;` — 行コメント

### ステップ 3: ビルドする

```bash
dotnet build
```

ビルド時に Source Generator が `EnemyAI.BuildTree.g.cs` を自動生成します。生成されるコードは以下のようになります:

```csharp
// <auto-generated by Crisp Source Generator/>
partial class EnemyAI
{
    public partial Crisp.Runtime.BtNode BuildTree()
    {
        return new Crisp.Runtime.Nodes.SelectorNode(
            new Crisp.Runtime.Nodes.SequenceNode(
                new Crisp.Runtime.Nodes.ConditionNode(() => (this.Health < 30), ".Health < 30"),
                new Crisp.Runtime.Nodes.ActionNode(() => this.Flee(), "Flee()")),
            new Crisp.Runtime.Nodes.SequenceNode(
                new Crisp.Runtime.Nodes.ConditionNode(() => this.IsEnemyVisible, ".IsEnemyVisible"),
                new Crisp.Runtime.Nodes.ActionNode(() => this.Attack(), "Attack()")),
            new Crisp.Runtime.Nodes.ActionNode(() => this.Patrol(), "Patrol()"));
    }
}
```

### ステップ 4: ツリーを実行する

```csharp
var ai = new EnemyAI { Health = 20, IsEnemyVisible = false };
var tree = ai.BuildTree();

// ゲームループで毎フレーム Tick を呼ぶ
var ctx = new TickContext(DeltaTime: 0.016f); // 60fps 想定
var status = tree.Tick(ctx);

Console.WriteLine($"結果: {status}");
// Health < 30 なので "逃走中..." が出力され、status == BtStatus.Success
```

### ステップ 5: 状態を変えて再実行する

```csharp
ai.Health = 80;
ai.IsEnemyVisible = true;

// 状態をリセットして再評価
tree.Reset();
status = tree.Tick(ctx);
// IsEnemyVisible == true なので "攻撃!" が出力される
```

`Reset()` はノードの内部状態をクリアします。状態が変わった後に再度ツリーを最初から評価する場合に呼び出します。

## チュートリアル 2: サブツリーの再利用

複数のツリーで共通のロジックを再利用したい場合、`BtNode` を返すメソッドを使ってサブツリーをコードで構築し、DSL から呼び出せます。

### サブツリーメソッドの定義

```csharp
public partial class EnemyAI
{
    // ...（チュートリアル 1 のプロパティ・メソッド）

    // BtNode を返すメソッド → サブツリーとしてツリーに埋め込まれる
    public BtNode BuildFleeSequence()
    {
        return new SequenceNode(
            new ConditionNode(() => this.Health < 30),
            new ActionNode(() => this.Flee()));
    }
}
```

### DSL からの呼び出し

```lisp
(tree EnemyCombat
  (select
    (.BuildFleeSequence)   ; BtNode を返す → サブツリー埋め込み
    (.Patrol)))            ; BtStatus を返す → アクション
```

`BtStatus` を返すメソッド（`.Patrol`）は毎 tick ラムダとして呼び出されますが、`BtNode` を返すメソッド（`.BuildFleeSequence`）はツリー構築時に 1 回だけ呼び出され、返された `BtNode` がツリーにそのまま埋め込まれます。

DSL の `ref` との使い分け:
- **`ref`** — 同じファイル（またはインポートファイル）内の別ツリーを参照。純粋に DSL で完結する再利用
- **`BtNode` メソッド** — C# コードでサブツリーを動的に構築。条件に応じたツリー構成や、DSL では表現しにくいロジックに最適

## チュートリアル 3: 条件分岐とデコレータ

より複雑なロジックを構築するために、デコレータノードを使います。

### guard（ガード）

`guard` は条件が `true` の場合のみ子ノードを実行します。`check` + `seq` の省略形です。

```lisp
(tree CombatAI
  (select
    ;; 体力 30 以下なら逃げる
    (guard (< .Health 30)
      (.Flee))
    ;; それ以外はパトロール
    (.Patrol)))
```

### if（条件分岐）

`if` は条件に基づいて異なるノードを実行します。

```lisp
(tree CombatAI
  (if .IsEnemyVisible
    (.Attack)    ;; then: 敵が見えたら攻撃
    (.Patrol)))  ;; else: 見えなければパトロール
```

### invert（反転）

`invert` は子ノードの結果を反転します（Success ↔ Failure）。

```lisp
;; 敵が見えていない場合に成功
(invert (check .IsEnemyVisible))
```

### repeat（繰り返し）

`repeat` は子ノードを指定回数実行します。

```lisp
;; パトロールを 3 回繰り返す
(repeat 3 (.Patrol))
```

### parallel（並列実行）

`parallel` は全ての子ノードを毎ティック実行します。ポリシーにより成功条件を制御できます。

```lisp
;; 全ての子が成功したら成功（デフォルト: :all）
(parallel :all
  (.MoveToTarget)
  (.PlayAnimation))

;; いずれか 1 つが成功したら成功
(parallel :any
  (.WaitForSignal)
  (.Timeout))
```

### timeout と cooldown

`timeout` は制限時間を設け、`cooldown` は実行間隔を制御します。

```lisp
;; 5 秒以内に完了しなければ Failure
(timeout 5.0 (.LongAction))

;; 最後の実行から 3 秒間は再実行しない
(cooldown 3.0 (.SpecialAttack))
```

### while（条件ループ）

`while` は条件が `true` の間、子ノードを繰り返し実行します。

```lisp
;; 体力が 50 以上の間、攻撃を続ける
(while (> .Health 50)
  (.Attack))
```

## チュートリアル 4: リアクティブノード

通常のノード（`select`, `guard` 等）は Running 状態の子ノードを次のティックで再開しますが、リアクティブノードは毎ティック条件を再評価し、条件が変わったら実行中の子を中断（Abort）します。

### reactive（リアクティブガード）

```lisp
(tree CombatAI
  (select
    ;; 敵が見えている間だけ攻撃を継続
    ;; 見えなくなったら攻撃を中断
    (reactive .IsEnemyVisible
      (.Attack))
    (.Patrol)))
```

`reactive` は毎ティック `.IsEnemyVisible` を評価します。攻撃中（Running）に敵が見えなくなった場合、攻撃を即座に中断（`Abort()`）して Failure を返します。

### reactive-select（リアクティブセレクター）

```lisp
(tree CombatAI
  ;; 毎ティック先頭から再評価し、優先度の高い行動に切り替え
  (reactive-select
    ;; 最優先: 体力が危険なら逃げる
    (guard (< .Health 20)
      (.Flee))
    ;; 次: 敵が見えたら攻撃
    (guard .IsEnemyVisible
      (.Attack))
    ;; 最低: パトロール
    (.Patrol)))
```

`reactive-select` は通常の `select` と異なり、毎ティック最初の子から評価を開始します。攻撃中（Running）に体力が 20 以下になった場合、攻撃を中断して逃走に切り替えます。

### reactive と select の違い

| | select | reactive-select |
|---|---|---|
| Running 子の扱い | 前回の Running 子から再開 | 毎ティック先頭から再評価 |
| 優先度の変化 | 対応しない | 自動的に対応 |
| 子の中断 | なし | 優先度の高い子が割り込み時に中断 |

## チュートリアル 5: ブラックボード

ブラックボードは、複数のツリーやエージェント間で共有するデータストアです。コンテキストクラスのメンバーとは別に、`$` プレフィックスでアクセスします。

### 定義

```csharp
// ブラックボードクラスは IBtBlackboard を実装
public class SharedBlackboard : IBtBlackboard
{
    public bool IsAlarmTriggered { get; set; }
    public Vector3 LastKnownPosition { get; set; }
}

public partial class GuardAI
{
    public BtStatus Investigate() => BtStatus.Running;
    public BtStatus RaiseAlarm() => BtStatus.Success;
    public BtStatus Patrol() => BtStatus.Success;
}
```

### DSL での使用

```lisp
;; ツリー名の後にブラックボード型を指定
(tree GuardBehavior SharedBlackboard
  (select
    ;; ブラックボードのプロパティを $ プレフィックスで参照
    (guard $.IsAlarmTriggered
      (.Investigate))
    (.Patrol)))
```

ブラックボードのメンバーは `$` プレフィックスで、コンテキストクラスのメンバーは `.` プレフィックスでアクセスします。

## チュートリアル 6: defdec でカスタムノードを定義する

`defdec`（decorator definition）を使うと、よく使うノードのパターンを再利用可能な名前付きテンプレートとして定義できます。

### 基本的な defdec

```lisp
;; 体力チェック付きガードを定義
(defdec low-health (threshold)
  (guard (< .Health threshold)
    <body>))

(tree CombatAI
  (select
    ;; defdec を使用: 体力 30 以下なら逃げる
    (low-health 30
      (.Flee))
    ;; 別のしきい値でも使える
    (low-health 50
      (.Heal))
    (.Patrol)))
```

`<body>` プレースホルダーは、呼び出し側で指定した子ノードに置き換えられます。

### パラメータ付き defdec

```lisp
;; タイムアウト付きリトライを定義
(defdec retry-with-timeout (max-retries timeout-sec)
  (timeout timeout-sec
    (repeat max-retries
      <body>)))

(tree WorkerAI
  ;; 3 回リトライ、10 秒でタイムアウト
  (retry-with-timeout 3 10.0
    (.DoWork)))
```

## チュートリアル 7: 非同期アクション

C# の `async/await` パターンを使う長時間処理をビヘイビアツリーに統合できます。

### コンテキストクラスの定義

```csharp
public partial class NavigationAI
{
    public Vector3 Destination { get; set; }

    // BtStatus を返すアクションは同期的に実行される
    public BtStatus Idle() => BtStatus.Success;

    // IAsyncOperation を返すファクトリは非同期アクションとして扱われる
    public IAsyncOperation NavigateTo(CancellationToken ct)
    {
        return new TaskAsyncOperation(NavigateAsync(ct));
    }

    private async Task<BtStatus> NavigateAsync(CancellationToken ct)
    {
        // 長時間の経路探索
        await pathfinder.FindPathAsync(Destination, ct);
        return BtStatus.Success;
    }
}
```

### DSL での使用

```lisp
(tree NavigationTree
  (select
    ;; .NavigateTo は IAsyncOperation を返すので自動的に非同期アクションになる
    ;; Running を返し続け、完了時に Success/Failure を返す
    (seq
      (check .HasDestination)
      (.NavigateTo))
    (.Idle)))
```

非同期アクションは以下の動作をします:
- 初回ティック: `IAsyncOperation` を生成し、Running を返す
- 以降のティック: 完了を確認し、未完了なら Running を返す
- 完了時: `GetResult()` の結果（Success/Failure）を返す
- 中断時: `CancellationToken` でキャンセルされる

## チュートリアル 8: デバッガ

ビヘイビアツリーの動作をデバッグするために、`BtDebugger` を使ってツリーの構造・実行状態・Blackboard 値のスナップショットを取得できます。

### スナップショットの取得

```csharp
using Crisp.Runtime;
using Crisp.Runtime.Debug;

var ai = new EnemyAI { Health = 20, IsEnemyVisible = false };
var tree = ai.BuildTree();

// ツリーを実行
var ctx = new TickContext(DeltaTime: 0.016f);
tree.Tick(ctx);

// デバッガでスナップショットを取得
var debugger = new BtDebugger(tree);
var snapshot = debugger.Capture();

// テキスト形式で出力
Console.WriteLine(BtDebugFormatter.Format(snapshot));
```

出力:

```
selector [Success]
+-- sequence [Success]
|   +-- check ".Health < 30" [Success]
|   \-- action "Flee()" [Success]
+-- sequence [-]
|   +-- check ".IsEnemyVisible" [-]
|   \-- action "Attack()" [-]
\-- action "Patrol()" [-]
```

`[-]` は未評価のノードを示します。`selector` は最初に成功したブランチで評価を終了するため、2 番目以降のブランチは評価されていません。

### Blackboard の状態を含める

```csharp
var blackboard = new WorldState { IsAlarmTriggered = true };
var debugger = new BtDebugger(tree, blackboard);
var snapshot = debugger.Capture();

Console.WriteLine(BtDebugFormatter.Format(snapshot));
```

出力の末尾に Blackboard の状態が追加されます:

```
...（ツリー構造）...

Blackboard (WorldState):
  IsAlarmTriggered = True
  GlobalThreatLevel = 0
```

### スナップショットをプログラムから利用

`BtNodeSnapshot` を直接走査して、プログラムから状態を確認することもできます。

```csharp
var snapshot = debugger.Capture();

// ルートノードの情報
Console.WriteLine(snapshot.Root.NodeType);   // "selector"
Console.WriteLine(snapshot.Root.LastStatus); // Success

// 子ノードの走査
foreach (var child in snapshot.Root.Children)
{
    Console.WriteLine($"{child.NodeType}: {child.LastStatus}");
}

// 特定のノードの状態確認
var firstCheck = snapshot.Root.Children[0].Children[0];
Console.WriteLine(firstCheck.Label);       // ".Health < 30"
Console.WriteLine(firstCheck.LastStatus);  // Success
```

### LastStatus でノードの最新状態を確認

各 `BtNode` は `LastStatus` プロパティで最後の `Tick` の結果を保持します。`Reset()` すると `null` にクリアされます。

```csharp
var node = new ActionNode(() => BtStatus.Running);

Console.WriteLine(node.LastStatus);  // null（未評価）

node.Tick(ctx);
Console.WriteLine(node.LastStatus);  // Running

node.Reset();
Console.WriteLine(node.LastStatus);  // null（クリア済み）
```

### IDebugSink でリアルタイムトレース

より詳細なデバッグ（ブレークポイント、ステップ実行、ノード評価のトレース）が必要な場合は、`IDebugSink` インターフェースを実装して `TickContext.Debug` に設定します。

```csharp
var debugSink = new MyDebugSink();
var ctx = new TickContext(DeltaTime: 0.016f, Debug: debugSink);
tree.Tick(ctx);
```

Source Generator はデバッグモード時に各ノードを `DebugProxyNode` でラップし、Tick の前後で `IDebugSink` のイベントを発火します。詳細は [ランタイム API](runtime-api.md#デバッガ-idebugsink) を参照してください。

## 外部ファイルの使い方

DSL コードが長くなる場合、`.crisp` ファイルに分離できます。

### 1. `.crisp` ファイルを作成する

```lisp
;; EnemyCombat.crisp
(tree EnemyCombat
  (select
    (seq
      (check (< .Health 30))
      (.Flee))
    (seq
      (check .IsEnemyVisible)
      (.Attack))
    (.Patrol)))
```

### 2. `.csproj` に AdditionalFiles として登録する

```xml
<ItemGroup>
  <AdditionalFiles Include="EnemyCombat.crisp" />
</ItemGroup>
```

ワイルドカードも使用できます:

```xml
<ItemGroup>
  <AdditionalFiles Include="**/*.crisp" />
</ItemGroup>
```

### 3. `[BehaviorTree]` でファイル名を指定する

```csharp
[BehaviorTree("EnemyCombat.crisp")]
public partial BtNode BuildTree();
```

Source Generator がビルド時にファイルを読み込み、コードを生成します。ファイル名はパスではなくファイル名部分のみで照合されます（大文字小文字は区別しません）。

## マルチツリー

複数のツリーを定義し、`ref` で参照できます。ツリーの再利用や分割に便利です。

### 同一ファイル内での参照

```lisp
;; サブツリーを定義
(tree FleeSequence
  (seq
    (check (< .Health 30))
    (.Flee)))

;; メインツリーから参照
(tree MainAI
  (select
    (ref FleeSequence)    ;; 別のツリーを参照
    (.Patrol)))
```

### 別ファイルからのインポート

```lisp
;; Combat.crisp
(import "shared-behaviors.crisp")

(tree CombatAI
  (select
    (ref SharedFlee)      ;; インポートしたファイルのツリーを参照
    (.Attack)))
```

`ref` はコンパイル時にインライン展開されるため、実行時のオーバーヘッドはありません。

## ホットリロード

`CrispRuntime` を使うと、アプリケーション実行中に DSL を再コンパイルできます。開発中のイテレーションに便利です。

```csharp
using Crisp.Syntax.Interpreter;

var ai = new EnemyAI();
var source = File.ReadAllText("Combat.crisp");

// DSL をコンパイルして Evaluator を取得
var (irTrees, evaluator) = CrispRuntime.CompileAndBuild(source, ai);

// 実行
var ctx = new TickContext(DeltaTime: 0.016f);
var status = evaluator.Evaluate(irTrees[0], ctx);

// ファイルが変更されたら再コンパイル
source = File.ReadAllText("Combat.crisp");
(irTrees, evaluator) = CrispRuntime.CompileAndBuild(source, ai);
```

ホットリロードはインタプリタ（リフレクション）で実行されるため、Source Generator による生成コードと比較してパフォーマンスは低下します。開発中のプロトタイピングやデバッグに使用してください。

## 次のステップ

- [言語リファレンス](language-reference.md) — DSL の全構文と文法を確認する
- [ランタイム API](runtime-api.md) — BtNode や組み込みノードの API を確認する
- [Source Generator ガイド](source-generator.md) — 生成の仕組みと AOT サポート
- [ビジュアルエディタ](visual-editor.md) — VSCode 拡張によるツリー可視化と双方向編集
- [エディタ統合 (LSP)](lsp.md) — エディタ上の開発支援機能
- [診断メッセージ一覧](diagnostics.md) — エラーが出た場合の対処法を確認する
- [アーキテクチャ概要](architecture.md) — コンパイラの内部構造を理解する
