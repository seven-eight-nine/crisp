using System.Collections.Immutable;
using System.Globalization;
using System.Text;
using Crisp.Syntax.Ast;
using Crisp.Syntax.IR;

namespace Crisp.Syntax.Emitter;

/// <summary>
/// C# コード生成器。IR ツリーを C# ソースコードに変換する。
/// 生成されたコードは <c>Crisp.Runtime</c> のノード型を使用して BtNode ツリーを構築する。
///
/// <para>
/// 変換規則の概要:
/// <list type="bullet">
///   <item><description><see cref="IrSelector"/> → <c>new SelectorNode(...)</c></description></item>
///   <item><description><see cref="IrSequence"/> → <c>new SequenceNode(...)</c></description></item>
///   <item><description><see cref="IrParallel"/> → <c>new ParallelNode(policy, ...)</c></description></item>
///   <item><description><see cref="IrCondition"/> → <c>new ConditionNode(() => expr)</c></description></item>
///   <item><description><see cref="IrAction"/> → <c>new ActionNode(() => this.Method(args))</c></description></item>
///   <item><description><see cref="IrGuard"/> → <c>new GuardNode(() => cond, body)</c></description></item>
///   <item><description><see cref="IrIf"/> → <c>new IfNode(() => cond, then, else?)</c></description></item>
///   <item><description><see cref="IrInvert"/> → <c>new InvertNode(child)</c></description></item>
///   <item><description><see cref="IrRepeat"/> → <c>new RepeatNode(n, child)</c></description></item>
///   <item><description><see cref="IrTimeout"/> → <c>new TimeoutNode(seconds, child)</c></description></item>
///   <item><description><see cref="IrCooldown"/> → <c>new CooldownNode(seconds, child)</c></description></item>
///   <item><description><see cref="IrWhile"/> → <c>new WhileNode(() => cond, body)</c></description></item>
/// </list>
/// </para>
/// </summary>
public static class CSharpEmitter
{
    /// <summary>インデント1レベルあたりのスペース数。</summary>
    private const int IndentSize = 4;

    /// <summary>using で参照するランタイムノードの名前空間。</summary>
    private const string RuntimeNodesNs = "Crisp.Runtime.Nodes";

    /// <summary>ランタイムの ParallelPolicy の完全修飾プレフィックス。</summary>
    private const string RuntimePolicyNs = "Crisp.Runtime.ParallelPolicy";

    // =================================================================
    //  パブリック API
    // =================================================================

    /// <summary>
    /// IR ツリーから完全な C# ソースファイルを生成する。
    /// 生成されるコードは partial クラスのメソッドとして BtNode ツリーを返す。
    /// </summary>
    /// <param name="tree">変換対象の IR ツリー。</param>
    /// <param name="namespaceName">生成クラスの名前空間。</param>
    /// <param name="className">生成クラスの名前（partial class として出力される）。</param>
    /// <param name="methodName">BtNode を返すメソッドの名前。</param>
    /// <returns>整形された C# ソースコード文字列。</returns>
    public static string Emit(IrTree tree, string namespaceName, string className, string methodName)
    {
        var sb = new StringBuilder();

        // ヘッダーコメント
        sb.AppendLine("// <auto-generated by Crisp Source Generator/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // using 宣言
        sb.AppendLine($"using {RuntimeNodesNs};");
        sb.AppendLine();

        // namespace 宣言
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        // partial class 宣言
        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");

        // メソッド宣言
        sb.AppendLine($"    public partial Crisp.Runtime.BtNode {methodName}()");
        sb.AppendLine("    {");

        // ツリー本体の生成（Body が単一ノードの場合はそのまま、複数の場合は SequenceNode でラップ）
        var bodyNode = tree.Body.Length == 1
            ? tree.Body[0]
            : new IrSequence(tree.Body);

        sb.Append("        return ");
        EmitNode(sb, bodyNode, indentLevel: 2);
        sb.AppendLine(";");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// IR ノードからノード構築式のみを生成する（テスト用）。
    /// ファイルヘッダーやクラス宣言は含まない。
    /// </summary>
    /// <param name="node">変換対象の IR ノード。</param>
    /// <returns>C# のノード構築式文字列。</returns>
    public static string EmitExpression(IrNode node)
    {
        var sb = new StringBuilder();
        EmitNode(sb, node, indentLevel: 0);
        return sb.ToString();
    }

    /// <summary>
    /// IR 式からC# 式文字列のみを生成する（テスト用）。
    /// </summary>
    /// <param name="expr">変換対象の IR 式。</param>
    /// <returns>C# の式文字列。</returns>
    public static string EmitExpressionString(IrExpr expr)
    {
        var sb = new StringBuilder();
        EmitExpr(sb, expr);
        return sb.ToString();
    }

    // =================================================================
    //  ノード生成（BtNode 構築式）
    // =================================================================

    /// <summary>
    /// IR ノードを対応する C# のノード構築式として StringBuilder に書き出す。
    /// 各ノード型に応じてランタイムのノードコンストラクタ呼び出しを生成する。
    /// </summary>
    private static void EmitNode(StringBuilder sb, IrNode node, int indentLevel)
    {
        switch (node)
        {
            case IrSelector sel:
                EmitCompositeNode(sb, "SelectorNode", sel.Children, indentLevel);
                break;

            case IrSequence seq:
                EmitCompositeNode(sb, "SequenceNode", seq.Children, indentLevel);
                break;

            case IrParallel par:
                EmitParallelNode(sb, par, indentLevel);
                break;

            case IrCondition cond:
                sb.Append($"new ConditionNode(() => ");
                EmitExpr(sb, cond.Expr);
                sb.Append(')');
                break;

            case IrAction act:
                if (act.IsSubtree)
                {
                    // BtNode を返すメソッド → 直接埋め込み（ActionNode ラッパー不要）
                    sb.Append("this.");
                    sb.Append(act.Method.Name);
                    sb.Append('(');
                    EmitArgList(sb, act.Args);
                    sb.Append(')');
                }
                else if (act.IsAsync)
                {
                    sb.Append($"new AsyncActionNode(ct => this.");
                    sb.Append(act.Method.Name);
                    sb.Append("(ct");
                    if (act.Args.Length > 0)
                    {
                        sb.Append(", ");
                        EmitArgList(sb, act.Args);
                    }
                    sb.Append("))");
                }
                else
                {
                    sb.Append($"new ActionNode(() => this.");
                    sb.Append(act.Method.Name);
                    sb.Append('(');
                    EmitArgList(sb, act.Args);
                    sb.Append("))");
                }
                break;

            case IrGuard guard:
                sb.Append("new GuardNode(() => ");
                EmitExpr(sb, guard.Condition);
                sb.Append(", ");
                EmitNode(sb, guard.Body, indentLevel);
                sb.Append(')');
                break;

            case IrIf ifNode:
                EmitIfNode(sb, ifNode, indentLevel);
                break;

            case IrInvert inv:
                sb.Append("new InvertNode(");
                EmitNode(sb, inv.Child, indentLevel);
                sb.Append(')');
                break;

            case IrRepeat rep:
                sb.Append($"new RepeatNode({rep.Count.ToString(CultureInfo.InvariantCulture)}, ");
                EmitNode(sb, rep.Child, indentLevel);
                sb.Append(')');
                break;

            case IrTimeout timeout:
                sb.Append($"new TimeoutNode({FormatFloat(timeout.Seconds)}, ");
                EmitNode(sb, timeout.Child, indentLevel);
                sb.Append(')');
                break;

            case IrCooldown cooldown:
                sb.Append($"new CooldownNode({FormatFloat(cooldown.Seconds)}, ");
                EmitNode(sb, cooldown.Child, indentLevel);
                sb.Append(')');
                break;

            case IrWhile whileNode:
                sb.Append("new WhileNode(() => ");
                EmitExpr(sb, whileNode.Condition);
                sb.Append(", ");
                EmitNode(sb, whileNode.Body, indentLevel);
                sb.Append(')');
                break;

            case IrReactive reactive:
                sb.Append("new ReactiveNode(() => ");
                EmitExpr(sb, reactive.Condition);
                sb.Append(", ");
                EmitNode(sb, reactive.Body, indentLevel);
                sb.Append(')');
                break;

            case IrReactiveSelect rsel:
                EmitCompositeNode(sb, "ReactiveSelectorNode", rsel.Children, indentLevel);
                break;

            case IrTreeRef treeRef:
                sb.Append($"Build{treeRef.TreeName}()");
                break;

            default:
                throw new InvalidOperationException($"未対応の IR ノード型: {node.GetType().Name}");
        }
    }

    /// <summary>
    /// 複合ノード（Selector / Sequence）の子ノードを改行・インデント付きで出力する。
    /// 子が2つ以上の場合は各子ノードを新しい行に配置して可読性を高める。
    /// </summary>
    private static void EmitCompositeNode(
        StringBuilder sb, string typeName, ImmutableArray<IrNode> children, int indentLevel)
    {
        if (children.Length <= 1)
        {
            // 子が0〜1個の場合は1行で出力
            sb.Append($"new {typeName}(");
            if (children.Length == 1)
            {
                EmitNode(sb, children[0], indentLevel);
            }
            sb.Append(')');
            return;
        }

        // 子が複数の場合は改行して出力
        sb.AppendLine($"new {typeName}(");
        for (var i = 0; i < children.Length; i++)
        {
            Indent(sb, indentLevel + 1);
            EmitNode(sb, children[i], indentLevel + 1);
            if (i < children.Length - 1)
                sb.AppendLine(",");
            else
                sb.Append(')');
        }
    }

    /// <summary>
    /// パラレルノードを出力する。
    /// ポリシーオブジェクトの構築式を最初の引数として、子ノードを続けて出力する。
    /// </summary>
    private static void EmitParallelNode(StringBuilder sb, IrParallel par, int indentLevel)
    {
        var policyExpr = par.Policy switch
        {
            ParallelPolicy.Any => $"new {RuntimePolicyNs}.Any()",
            ParallelPolicy.All => $"new {RuntimePolicyNs}.All()",
            ParallelPolicy.N n => $"new {RuntimePolicyNs}.N({n.Count.ToString(CultureInfo.InvariantCulture)})",
            _ => throw new InvalidOperationException($"未対応の ParallelPolicy: {par.Policy.GetType().Name}")
        };

        if (par.Children.Length <= 1)
        {
            sb.Append($"new ParallelNode({policyExpr}");
            if (par.Children.Length == 1)
            {
                sb.Append(", ");
                EmitNode(sb, par.Children[0], indentLevel);
            }
            sb.Append(')');
            return;
        }

        sb.AppendLine($"new ParallelNode({policyExpr},");
        for (var i = 0; i < par.Children.Length; i++)
        {
            Indent(sb, indentLevel + 1);
            EmitNode(sb, par.Children[i], indentLevel + 1);
            if (i < par.Children.Length - 1)
                sb.AppendLine(",");
            else
                sb.Append(')');
        }
    }

    /// <summary>
    /// if ノードを出力する。else が null の場合は省略される。
    /// </summary>
    private static void EmitIfNode(StringBuilder sb, IrIf ifNode, int indentLevel)
    {
        sb.Append("new IfNode(() => ");
        EmitExpr(sb, ifNode.Condition);
        sb.Append(", ");
        EmitNode(sb, ifNode.Then, indentLevel);
        if (ifNode.Else != null)
        {
            sb.Append(", ");
            EmitNode(sb, ifNode.Else, indentLevel);
        }
        sb.Append(')');
    }

    // =================================================================
    //  式生成
    // =================================================================

    /// <summary>
    /// IR 式を対応する C# 式として StringBuilder に書き出す。
    /// 式はラムダ本体やメソッド引数として使用されるため、文（statement）ではなく式として出力する。
    /// </summary>
    private static void EmitExpr(StringBuilder sb, IrExpr expr)
    {
        switch (expr)
        {
            case IrMemberLoad mem:
                sb.Append("this.");
                for (var i = 0; i < mem.Ref.Chain.Length; i++)
                {
                    if (i > 0) sb.Append('.');
                    sb.Append(mem.Ref.Chain[i]);
                }
                break;

            case IrBlackboardLoad bb:
                sb.Append("blackboard.");
                for (var i = 0; i < bb.Ref.Chain.Length; i++)
                {
                    if (i > 0) sb.Append('.');
                    sb.Append(bb.Ref.Chain[i]);
                }
                break;

            case IrLiteral lit:
                EmitLiteral(sb, lit);
                break;

            case IrBinaryOp bin:
                sb.Append('(');
                EmitExpr(sb, bin.Lhs);
                sb.Append(' ');
                sb.Append(BinaryOpSymbol(bin.Op));
                sb.Append(' ');
                EmitExpr(sb, bin.Rhs);
                sb.Append(')');
                break;

            case IrUnaryOp unary:
                sb.Append('(');
                sb.Append(UnaryOpSymbol(unary.Op));
                EmitExpr(sb, unary.Operand);
                sb.Append(')');
                break;

            case IrLogicOp logic:
                sb.Append('(');
                var logicSep = logic.Op == LogicOp.And ? " && " : " || ";
                for (var i = 0; i < logic.Operands.Length; i++)
                {
                    if (i > 0) sb.Append(logicSep);
                    EmitExpr(sb, logic.Operands[i]);
                }
                sb.Append(')');
                break;

            case IrCall call:
                sb.Append("this.");
                sb.Append(call.Method.Name);
                sb.Append('(');
                EmitArgList(sb, call.Args);
                sb.Append(')');
                break;

            case IrConvert conv:
                sb.Append("((");
                sb.Append(conv.TargetType.FullName);
                sb.Append(')');
                EmitExpr(sb, conv.Operand);
                sb.Append(')');
                break;

            default:
                throw new InvalidOperationException($"未対応の IR 式型: {expr.GetType().Name}");
        }
    }

    /// <summary>
    /// リテラル式を出力する。種別に応じて適切なC#リテラル表現を生成する。
    /// </summary>
    private static void EmitLiteral(StringBuilder sb, IrLiteral lit)
    {
        switch (lit.Kind)
        {
            case LiteralKind.Int:
                sb.Append(Convert.ToInt32(lit.Value, CultureInfo.InvariantCulture)
                    .ToString(CultureInfo.InvariantCulture));
                break;

            case LiteralKind.Float:
                sb.Append(FormatFloat(Convert.ToSingle(lit.Value, CultureInfo.InvariantCulture)));
                break;

            case LiteralKind.Bool:
                sb.Append((bool)lit.Value! ? "true" : "false");
                break;

            case LiteralKind.String:
                sb.Append('"');
                sb.Append(EscapeString((string)lit.Value!));
                sb.Append('"');
                break;

            case LiteralKind.Null:
                sb.Append("null");
                break;

            case LiteralKind.Enum:
                var enumRef = (EnumRef)lit.Value!;
                sb.Append(enumRef.TypeName);
                sb.Append('.');
                sb.Append(enumRef.MemberName);
                break;

            default:
                throw new InvalidOperationException($"未対応のリテラル種別: {lit.Kind}");
        }
    }

    // =================================================================
    //  ヘルパー
    // =================================================================

    /// <summary>
    /// メソッド引数リストをカンマ区切りで出力する。
    /// </summary>
    private static void EmitArgList(StringBuilder sb, ImmutableArray<IrExpr> args)
    {
        for (var i = 0; i < args.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            EmitExpr(sb, args[i]);
        }
    }

    /// <summary>
    /// 指定レベルのインデント（4スペース x レベル）を追加する。
    /// </summary>
    private static void Indent(StringBuilder sb, int level)
    {
        sb.Append(new string(' ', level * IndentSize));
    }

    /// <summary>
    /// 浮動小数点数を C# リテラル形式（<c>f</c> サフィックス付き）でフォーマットする。
    /// 小数点が含まれない場合でも <c>.0f</c> ではなく <c>f</c> を付与する。
    /// 例: 2.5 → <c>2.5f</c>、3 → <c>3f</c>
    /// </summary>
    private static string FormatFloat(float value)
    {
        var s = value.ToString(CultureInfo.InvariantCulture);
        return s + "f";
    }

    /// <summary>
    /// 文字列リテラル内のエスケープが必要な文字をエスケープする。
    /// バックスラッシュ・ダブルクォート・改行・タブ等を処理する。
    /// </summary>
    private static string EscapeString(string value)
    {
        var sb = new StringBuilder(value.Length);
        foreach (var c in value)
        {
            switch (c)
            {
                case '\\': sb.Append("\\\\"); break;
                case '"': sb.Append("\\\""); break;
                case '\n': sb.Append("\\n"); break;
                case '\r': sb.Append("\\r"); break;
                case '\t': sb.Append("\\t"); break;
                case '\0': sb.Append("\\0"); break;
                default: sb.Append(c); break;
            }
        }
        return sb.ToString();
    }

    /// <summary>
    /// 二項演算子を C# の演算子記号に変換する。
    /// </summary>
    private static string BinaryOpSymbol(BinaryOp op) => op switch
    {
        BinaryOp.Add => "+",
        BinaryOp.Sub => "-",
        BinaryOp.Mul => "*",
        BinaryOp.Div => "/",
        BinaryOp.Mod => "%",
        BinaryOp.Lt => "<",
        BinaryOp.Gt => ">",
        BinaryOp.Le => "<=",
        BinaryOp.Ge => ">=",
        BinaryOp.Eq => "==",
        BinaryOp.Ne => "!=",
        _ => throw new InvalidOperationException($"未対応の二項演算子: {op}")
    };

    /// <summary>
    /// 単項演算子を C# の演算子記号に変換する。
    /// </summary>
    private static string UnaryOpSymbol(UnaryOp op) => op switch
    {
        UnaryOp.Not => "!",
        UnaryOp.Negate => "-",
        _ => throw new InvalidOperationException($"未対応の単項演算子: {op}")
    };
}
